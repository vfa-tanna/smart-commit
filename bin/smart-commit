#!/usr/bin/env python3
"""
Smart Commit Agent
Main script that orchestrates diff checking, message generation, and committing
"""

import sys
import os
import argparse
import subprocess
import json
from pathlib import Path

# Add lib directory to Python path
sys.path.insert(0, os.path.join(os.path.dirname(os.path.abspath(__file__)), '..', 'lib'))

from diff_analyzer import DiffAnalyzer
from message_generator import MessageGenerator

class SmartCommitAgent:
    def __init__(self):
        self.analyzer = DiffAnalyzer()
        self.generator = MessageGenerator()

    def check_git_repo(self) -> bool:
        """Check if we're in a git repository"""
        try:
            subprocess.run(['git', 'rev-parse', '--git-dir'], 
                          capture_output=True, check=True)
            return True
        except subprocess.CalledProcessError:
            return False

    def check_staged_changes(self) -> bool:
        """Check if there are staged changes to commit"""
        try:
            result = subprocess.run(['git', 'diff', '--cached', '--name-only'], 
                                  capture_output=True, text=True, check=True)
            return bool(result.stdout.strip())
        except subprocess.CalledProcessError:
            return False

    def stage_all_changes(self) -> bool:
        """Stage all modified files"""
        try:
            subprocess.run(['git', 'add', '-A'], check=True)
            return True
        except subprocess.CalledProcessError:
            return False

    def commit_with_message(self, message: str) -> bool:
        """Commit staged changes with the given message"""
        try:
            subprocess.run(['git', 'commit', '-m', message], check=True)
            return True
        except subprocess.CalledProcessError:
            return False

    def get_user_choice(self, options: list, prompt: str = "Choose an option") -> int:
        """Get user choice from a list of options"""
        print(f"\n{prompt}:")
        for i, option in enumerate(options, 1):
            print(f"{i}. {option}")
        
        while True:
            try:
                choice = input(f"\nEnter choice (1-{len(options)}): ").strip()
                idx = int(choice) - 1
                if 0 <= idx < len(options):
                    return idx
                else:
                    print(f"Please enter a number between 1 and {len(options)}")
            except ValueError:
                print("Please enter a valid number")

    def interactive_commit(self) -> bool:
        """Interactive commit workflow"""
        print("ğŸ” Analyzing changes...")
        
        # Analyze the changes
        analysis = self.analyzer.analyze_changes()
        
        if not any(analysis['status'].values()):
            print("âŒ No changes detected to commit")
            return False

        # Display analysis summary
        print("\nğŸ“Š Change Analysis:")
        print(f"   Type: {analysis['change_type']}")
        print(f"   Scope: {analysis.get('scope', 'general')}")
        print(f"   Files: {analysis['stats']['files_changed']}")
        print(f"   Lines: +{analysis['stats']['insertions']} -{analysis['stats']['deletions']}")
        
        if analysis['entities']:
            print(f"   Functions/Classes: {', '.join(analysis['entities'])}")

        # Generate message suggestions
        print("\nğŸ’¡ Suggested commit messages:")
        suggestions = self.generator.suggest_multiple_messages(analysis)
        
        # Add options for custom message and cancel
        options = suggestions + ["Write custom message", "Cancel"]
        choice_idx = self.get_user_choice(options, "Select a commit message")
        
        if choice_idx == len(suggestions) + 1:  # Cancel
            print("âŒ Commit cancelled")
            return False
        elif choice_idx == len(suggestions):  # Custom message
            message = input("\nEnter your commit message: ").strip()
            if not message:
                print("âŒ Empty message, commit cancelled")
                return False
        else:
            message = suggestions[choice_idx]

        # Validate the message
        is_valid, errors = self.generator.validate_message(message)
        if not is_valid:
            print(f"\nâš ï¸  Message validation warnings:")
            for error in errors:
                print(f"   - {error}")
            
            continue_anyway = input("\nContinue anyway? (y/N): ").strip().lower()
            if continue_anyway != 'y':
                print("âŒ Commit cancelled")
                return False

        # Show final message and confirm
        print(f"\nğŸ“ Final commit message:")
        print(f'   "{message}"')
        
        confirm = input("\nProceed with commit? (Y/n): ").strip().lower()
        if confirm in ['', 'y', 'yes']:
            if self.commit_with_message(message):
                print("âœ… Commit successful!")
                return True
            else:
                print("âŒ Commit failed")
                return False
        else:
            print("âŒ Commit cancelled")
            return False

    def auto_commit(self, custom_message: str = None) -> bool:
        """Automatic commit with generated message"""
        analysis = self.analyzer.analyze_changes()
        
        if not any(analysis['status'].values()):
            print("âŒ No changes detected to commit")
            return False

        if custom_message:
            message = custom_message
        else:
            # Use the first (best) suggestion
            suggestions = self.generator.suggest_multiple_messages(analysis, count=1)
            message = suggestions[0] if suggestions else "chore: update files"

        print(f"ğŸ“ Committing with message: \"{message}\"")
        
        if self.commit_with_message(message):
            print("âœ… Commit successful!")
            return True
        else:
            print("âŒ Commit failed")
            return False

    def show_analysis_only(self) -> None:
        """Show analysis without committing"""
        print("ğŸ” Analyzing changes...")
        analysis = self.analyzer.analyze_changes()
        
        print("\nğŸ“Š Detailed Analysis:")
        print(json.dumps(analysis, indent=2, default=str))
        
        print("\nğŸ’¡ Suggested commit messages:")
        suggestions = self.generator.suggest_multiple_messages(analysis)
        for i, msg in enumerate(suggestions, 1):
            print(f"{i}. {msg}")

def main():
    parser = argparse.ArgumentParser(description="Smart Git Commit Agent")
    parser.add_argument('-a', '--auto', action='store_true', 
                       help='Automatically commit with generated message')
    parser.add_argument('-m', '--message', type=str, 
                       help='Custom commit message')
    parser.add_argument('-s', '--stage-all', action='store_true',
                       help='Stage all changes before committing')
    parser.add_argument('--analyze-only', action='store_true',
                       help='Only analyze changes, don\'t commit')
    parser.add_argument('--dry-run', action='store_true',
                       help='Show what would be committed without actually committing')

    args = parser.parse_args()
    
    agent = SmartCommitAgent()
    
    # Check if we're in a git repository
    if not agent.check_git_repo():
        print("âŒ Not in a git repository")
        sys.exit(1)
    
    # Stage all changes if requested
    if args.stage_all:
        print("ğŸ“¥ Staging all changes...")
        if not agent.stage_all_changes():
            print("âŒ Failed to stage changes")
            sys.exit(1)
    
    # Check for staged changes
    if not agent.check_staged_changes():
        print("âŒ No staged changes to commit")
        print("ğŸ’¡ Use 'git add <files>' to stage changes or use --stage-all flag")
        sys.exit(1)
    
    # Handle different modes
    if args.analyze_only:
        agent.show_analysis_only()
    elif args.dry_run:
        print("ğŸ” Dry run - showing what would be committed:")
        agent.show_analysis_only()
    elif args.auto:
        success = agent.auto_commit(args.message)
        sys.exit(0 if success else 1)
    else:
        success = agent.interactive_commit()
        sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()